#
# guppy.ldef - language definitions for Guppy
# identifiers must start at the left-margin, indentation is a line-continuation
#

.IDENT		"guppy"
.DESC		"Guppy parallel programming language"
.MAINTAINER	"Fred Barnes <frmb@kent.ac.uk>"


# sections are used to help front-end units find their definitions

.SECTION "guppy" # {{{: fairly general guppy reductions and other language things

.GRULE	"gup:nullreduce" "N+R-"
.GRULE	"gup:nullpush" "0N-"
.GRULE	"gup:nullset" "0R-"

.GRULE	"gup:testtrue" "T*C[TESTTRUE]0R-"
.GRULE	"gup:testfalse" "T*C[TESTFALSE]0R-"

.GRULE	"gup:rewindlexer" "T*"

# .TNODE directives describe the parse-tree, kind-of

#{{{  declarations and related nodes

# guppy:rawnamenode		(0,0,1)

.TNODE	"guppy:rawnamenode" (0,0,1) "name-hook"
	INVALID AFTER "scope"
.TNODE	"guppy:namenode" (0,1,0) "name"
	INVALID BEFORE "scope"


#}}}

# }}}

.SECTION "guppy-postprod" # {{{: top-level grammar, kind-of

.TABLE	"guppy:procstart +:= [ 0 guppy:primproc 1 ] [ 0 guppy:cnode 1 ] [ 1 {<gup:nullreduce>} -* ]"
	"[ 0 +Name 2 ] [ 2 +Name 3 ] [ 3 {<gup:rewindlexer>} -* <guppy:namenamestartproc> ]"
	"[ 2 -* 4 ] [ 4 {<gup:rewindlexer>} -* <guppy:namestartproc> ]"

#.BNF	"guppy:procstart +:= ( guppy:primproc | guppy:cnode ) {<gup:nullreduce>}"

# definitions that start with 'define' use "guppy:definedecl" ('define' already eaten),
# others use "guppy:otherdecl".

.TABLE	"guppy:decl +:= [ 0 @define 1 ] [ 1 -* <guppy:definedecl> ] [ 0 -* <guppy:otherdecl> ]"

.TABLE	"guppy:testfordecl +:= [ 0 +@define 1 ] [ 1 {<gup:testtrue>} -* ]"
	"[ 0 -* 2 ] [ 2 {<gup:testfalse>} -* ]"

.TABLE	"guppy:namestartproc +:= [ 0 +Name 1 ] [ 1 +@@= 2 ] [ 2 {<gup:rewindlexer>} -* <guppy:oneassign> ]"

# }}}


.SECTION "guppy-decls" # {{{: variables and other named things

.GRULE	"gup:namereduce" "T+St0X[guppy_nametoken_to_hook]C[NAME]1R-"
.GRULE	"gup:namepush" "T+St0X[guppy_nametoken_to_hook]C[NAME]1N-"

.GRULE	"gup:fparam2nsreduce" "N+Sn0N+C[FPARAM]2M[fparam][FPARAM]R-"
.GRULE	"gup:vardeclreduce" "N+N+C[VARDECL]2R-"

.GRULE	"gup:enumreduce" "SN0N+0C[ENUMDEF]2R-"

.BNF	"guppy:name ::= +Name {<gup:namereduce>}"
.BNF	"guppy:namelist ::= { guppy:name @@, 1 }"

.TABLE	"guppy:expr +:= [ 0 guppy:name 1 ] [ 1 {<gup:nullreduce>} -* 2 ] [ 2 -* <guppy:restofexpr> ]"

.TABLE	"guppy:fparam ::= [ 0 guppy:primtype 1 ] [ 1 guppy:name 2 ] [ 2 {<gup:fparam2nsreduce>} -* ]"

.BNF	"guppy:fparamlist ::= ( -@@) {<gup:nullset>} | { guppy:fparam @@, 1 } )"

.TABLE	"guppy:otherdecl +:= [ 0 guppy:type 1 ] [ 1 guppy:nameandassignlist 2 ] [ 2 {<gup:vardeclreduce>} -* ]"

.TABLE	"guppy:testfordecl +:= [ 0 +@int 1 ] [ 0 +@real 1 ] [ 0 +@bool 1 ] [ 0 +@byte 1 ] [ 0 +@char 1 ] [ 0 +@string 1 ]"
	"[ 1 {<gup:testtrue>} -* ]"

.TABLE	"guppy:definedecl +:= [ 0 @enum 1 ] [ 1 guppy:name 2 ] [ 2 {<gup:enumreduce>} -* ]"

.TABLE	"guppy:nameandassign ::= [ 0 guppy:name 1 ] [ 1 @@= 3 ] [ 1 -* 2 ] [ 2 {<gup:nullreduce>} -* ]"
	"[ 3 guppy:expr 4 ] [ 4 {<gup:assignreduce>} -* ]"

.BNF	"guppy:nameandassignlist ::= { guppy:nameandassign @@, 1 }"

# when we come in here, lexer is rewound (two names waiting)
.TABLE	"guppy:namenamestartproc +:= [ 0 guppy:name 1 ] [ 1 guppy:nameandassignlist 2 ] [ 2 {<gup:vardeclreduce>} -* ]"


# }}}
.SECTION "guppy-lit" # {{{: literals

.GRULE	"gup:litintreduce" "T+St0X[guppy_token_to_lithook]0VC[LITINT]2R-"

.TABLE	"guppy:literal ::= [ 0 +Integer 1 ] [ 1 {<gup:litintreduce>} -* ]"

.TABLE	"guppy:expr +:= [ 0 guppy:literal 1 ] [ 1 {<gup:nullreduce>} -* 2 ] [ 2 -* <guppy:restofexpr> ]"

# }}}
.SECTION "guppy-types" # {{{: types

.RFUNC	"Rguppy:primtype" "guppy_reduce_primtype"

.BNF	"guppy:primtype ::= ( +@int | +@uint | +@real | +@bool | +@byte | +@char | +@string ) {Rguppy:primtype}"

.BNF	"guppy:type ::= ( guppy:primtype {<gup:nullreduce>} )"

# }}}
.SECTION "guppy-fcndef" # {{{: function/procedure definitions

.GRULE	"gup:fcndefreduce" "SN1N+N+V0C[FCNDEF]3R-"
.GRULE	"gup:fcndefreduce1" "SN0N+00C[FCNDEF]3R-"

.TABLE	"guppy:definedecl +:= [ 0 guppy:name 1 ] [ 1 @@( 3 ] [ 1 -* 2 ] [ 2 {<gup:fcndefreduce1>} -* ]"
	"[ 3 guppy:fparamlist 4 ] [ 4 @@) 5 ] [ 5 {<gup:fcndefreduce>} -* ]"

# }}}
.SECTION "guppy-primproc" # {{{: primitive processes

.RFUNC	"Rguppy:primproc" "guppy_reduce_primproc"

.BNF	"guppy:primproc ::= ( +@skip | +@stop ) {Rguppy:primproc}"

# }}}
.SECTION "guppy-cnode" # {{{: constructor processes

.GRULE	"gup:seqreduce" "T+St0@t00C[SEQ]2R-"
.GRULE	"gup:parreduce" "T+St0@t00C[PAR]2R-"

.TABLE	"guppy:cnode ::= [ 0 +@seq 1 ] [ 1 -Newline 2 ] [ 2 {<gup:seqreduce>} -* ]"
	"[ 0 +@par 3 ] [ 3 -Newline 4 ] [ 4 {<gup:parreduce>} -* ]"

# }}}
.SECTION "guppy-cflow" # {{{: control-flow processes

.GRULE	"gup:ifreduce" "T+St0@tN+0C[IF]2R-"

.TABLE	"guppy:cflow ::= [ 0 +@if 1 ] [ 1 guppy:expr 2 ] [ 2 -Newline 3 ] [ 3 {<gup:ifreduce>} -* ]"

# }}}
.SECTION "guppy-assign" # {{{: assignment

.GRULE	"gup:assignreduce" "SN0N+N+V0C[ASSIGN]3R-"

.TABLE	"guppy:oneassign ::= [ 0 guppy:name 1 ] [ 1 @@= 2 ] [ 2 guppy:expr 3 ] [ 3 {<gup:assignreduce>} -* ]"

# }}}
.SECTION "guppy-io" # {{{: input/output


# }}}
.SECTION "guppy-oper" # {{{: operators

.GRULE	"gup:foldaddreduce" "R+N+Sn00C[ADD]3R-"
.GRULE	"gup:foldsubreduce" "R+N+Sn00C[SUB]3R-"

# for "guppy:restofexpr" existing expression is result already
.TABLE	"guppy:restofexpr +:= [ 0 @@+ 1 ] [ 1 guppy:expr 2 ] [ 2 {<gup:foldaddreduce>} -* ]"
	"[ 0 @@- 3 ] [ 3 guppy:expr 4 ] [ 4 {<gup:foldsubreduce>} -* ]"
	"[ 0 -* ]"

# }}}


