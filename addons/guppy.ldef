#
# guppy.ldef - language definitions for Guppy
# identifiers must start at the left-margin, indentation is a line-continuation
#

.IDENT		"guppy"
.DESC		"Guppy parallel programming language"
.MAINTAINER	"Fred Barnes <frmb@kent.ac.uk>"


# sections are used to help front-end units find their definitions

.SECTION "guppy" # {{{: fairly general guppy reductions and other language things

.GRULE	"gup:nullreduce" "N+R-"
.GRULE	"gup:nullpush" "0N-"
.GRULE	"gup:null2push" "0N-0N-"
.GRULE	"gup:nullset" "0R-"

.GRULE	"gup:testtrue" "T*C[TESTTRUE]0R-"
.GRULE	"gup:testfalse" "T*C[TESTFALSE]0R-"

.GRULE	"gup:rewindlexer" "T*"

# .TNODE directives describe the parse-tree, kind-of

#{{{  declarations and related nodes

# guppy:rawnamenode		(0,0,1)

.TNODE	"guppy:rawnamenode" (0,0,1) "name-hook"
	INVALID AFTER "scope"
.TNODE	"guppy:namenode" (0,1,0) "name"
	INVALID BEFORE "scope"


#}}}

# }}}

.SECTION "guppy-postprod" # {{{: top-level grammar, kind-of

.TABLE	"guppy:procstart +:= [ 0 guppy:primproc 1 ] [ 0 guppy:cnode 1 ] [ 1 {<gup:nullreduce>} -* ]"
	"[ 0 +Name 2 ] [ 2 +Name 3 ] [ 3 {<gup:rewindlexer>} -* <guppy:namenamestartproc> ]"
	"[ 2 -* 4 ] [ 4 {<gup:rewindlexer>} -* <guppy:namestartproc> ]"

#.BNF	"guppy:procstart +:= ( guppy:primproc | guppy:cnode ) {<gup:nullreduce>}"

# definitions that start with 'define' use "guppy:definedecl" ('define' already eaten),
# others use "guppy:otherdecl".

.TABLE	"guppy:decl +:= [ 0 @define 1 ] [ 1 -* <guppy:definedecl> ] [ 0 -* <guppy:otherdecl> ]"

.TABLE	"guppy:testfordecl +:= [ 0 +@define 1 ] [ 1 {<gup:testtrue>} -* ]"
	"[ 0 -* 2 ] [ 2 {<gup:testfalse>} -* ]"

.TABLE	"guppy:namestartproc +:= [ 0 +Name 1 ] [ 1 +@@= 2 ] [ 2 {<gup:rewindlexer>} -* <guppy:oneassign> ]"
.TABLE	"guppy:namestartproc +:= [ 0 +Name 1 ] [ 1 +@@? 2 ] [ 2 {<gup:rewindlexer>} -* <guppy:input> ]"
.TABLE	"guppy:namestartproc +:= [ 0 +Name 1 ] [ 1 +@@! 2 ] [ 2 {<gup:rewindlexer>} -* <guppy:output> ]"
.TABLE	"guppy:namestartproc +:= [ 0 +Name 1 ] [ 1 +@@( 2 ] [ 2 {<gup:rewindlexer>} -* <guppy:instance> ]"

# }}}


.SECTION "guppy-decls" # {{{: variables and other named things

.GRULE	"gup:namereduce" "T+St0X[guppy_nametoken_to_hook]C[NAME]1R-"
.GRULE	"gup:namepush" "T+St0X[guppy_nametoken_to_hook]C[NAME]1N-"

.GRULE	"gup:fparam2nsreduce" "N+Sn0N+0C[FPARAM]3M[fparam][FPARAM]R-"
.GRULE	"gup:vardeclreduce" "N+N+0C[VARDECL]3R-"

.GRULE	"gup:enumreduce" "SN0N+0C[ENUMDEF]2R-"

.BNF	"guppy:name ::= +Name {<gup:namereduce>}"
.BNF	"guppy:namelist ::= { guppy:name @@, 1 }"

.TABLE	"guppy:expr +:= [ 0 guppy:name 1 ] [ 1 {<gup:nullreduce>} -* 2 ] [ 2 -* <guppy:restofexpr> ]"

.TABLE	"guppy:fparam ::= [ 0 guppy:type 1 ] [ 1 guppy:name 2 ] [ 2 {<gup:fparam2nsreduce>} -* ]"

.BNF	"guppy:fparamlist ::= ( -@@) {<gup:nullset>} | { guppy:fparam @@, 1 } )"

.TABLE	"guppy:otherdecl +:= [ 0 guppy:type 1 ] [ 1 guppy:nameandassignlist 2 ] [ 2 {<gup:vardeclreduce>} -* ]"

.TABLE	"guppy:testfordecl +:= [ 0 +@val 1 ] [ 0 +@int 1 ] [ 0 +@real 1 ] [ 0 +@bool 1 ] [ 0 +@byte 1 ] [ 0 +@char 1 ] [ 0 +@string 1 ] [ 0 +@chan 1 ]"
	"[ 1 {<gup:testtrue>} -* ]"

.TABLE	"guppy:definedecl +:= [ 0 @enum 1 ] [ 1 guppy:name 2 ] [ 2 {<gup:enumreduce>} -* ]"

.TABLE	"guppy:nameandassign ::= [ 0 guppy:name 1 ] [ 1 @@= 3 ] [ 1 @is 5 ] [ 1 -* 2 ] [ 2 {<gup:nullreduce>} -* ]"
	"[ 3 guppy:expr 4 ] [ 4 {<gup:assignreduce>} -* ]"
	"[ 5 guppy:expr 6 ] [ 6 {<gup:isreduce>} -* ]"

.BNF	"guppy:nameandassignlist ::= { guppy:nameandassign @@, 1 }"

# when we come in here, lexer is rewound (two names waiting)
.TABLE	"guppy:namenamestartproc +:= [ 0 guppy:name 1 ] [ 1 guppy:nameandassignlist 2 ] [ 2 {<gup:vardeclreduce>} -* ]"


# }}}
.SECTION "guppy-lit" # {{{: literals

.GRULE	"gup:litintreduce" "T+St0X[guppy_token_to_lithook]0VC[LITINT]2R-"
.GRULE	"gup:litrealreduce" "T+St0X[guppy_token_to_lithook]0VC[LITREAL]2R-"
.GRULE	"gup:litstringreduce" "T+St0X[guppy_token_to_lithook]0VC[LITSTRING]2R-"

.TABLE	"guppy:literal ::= [ 0 +Integer 1 ] [ 1 {<gup:litintreduce>} -* ] [ 0 +Real 2 ] [ 2 {<gup:litrealreduce>} -* ]"
			"[ 0 +String 3 ] [ 3 {<gup:litstringreduce>} -* ]"

.TABLE	"guppy:expr +:= [ 0 guppy:literal 1 ] [ 1 {<gup:nullreduce>} -* 2 ] [ 2 -* <guppy:restofexpr> ]"

# }}}
.SECTION "guppy-types" # {{{: types

.RFUNC	"Rguppy:primtype" "guppy_reduce_primtype"
.RFUNC	"Rguppy:chantype" "guppy_reduce_chantype"

.GRULE	"gup:valtypereduce" "SN0N+C[VALTYPE]1R-"

.BNF	"guppy:primtype ::= ( +@int | +@uint | +@real | +@bool | +@byte | +@char | +@string ) {Rguppy:primtype}"

.TABLE	"guppy:chantype ::= [ 0 +@chan 1 ] [ 1 +@@? 2 ] [ 1 +@@! 2 ] [ 1 -* 2 ]"
	"[ 2 @@( 3 ] [ 3 guppy:type 4 ] [ 4 @@) 5 ] [ 5 {Rguppy:chantype} -* ]"

.BNF	"guppy:subtype ::= ( guppy:primtype {<gup:nullreduce>} | guppy:chantype {<gup:nullreduce>} )"
.TABLE	"guppy:type ::= [ 0 %guppy:subtype 3 ] [ 0 @val 1 ] [ 1 guppy:subtype 2 ] [ 2 {<gup:valtypereduce>} -* ]"
	"[ 3 guppy:subtype 4 ] [ 4 {<gup:nullreduce>} -* ]"


# }}}
.SECTION "guppy-fcndef" # {{{: function/procedure definitions

.GRULE	"gup:fcndefreduce" "SN1N+N+V000C[FCNDEF]5R-"
.GRULE	"gup:fcndefreduce1" "SN0N+0000C[FCNDEF]5R-"

.TABLE	"guppy:definedecl +:= [ 0 guppy:name 1 ] [ 1 @@( 3 ] [ 1 -* 2 ] [ 2 {<gup:fcndefreduce1>} -* ]"
	"[ 3 guppy:fparamlist 4 ] [ 4 @@) 5 ] [ 5 {<gup:fcndefreduce>} -* ]"

# }}}
.SECTION "guppy-primproc" # {{{: primitive processes

.RFUNC	"Rguppy:primproc" "guppy_reduce_primproc"

.BNF	"guppy:primproc ::= ( +@skip | +@stop ) {Rguppy:primproc}"

# }}}
.SECTION "guppy-cnode" # {{{: constructor processes

.GRULE	"gup:seqreduce" "T+St0@t00C[SEQ]2R-"
.GRULE	"gup:parreduce" "T+St0@t00C[PAR]2R-"

.GRULE	"gup:replseqreduce" "T+St0@tN+N+N+00V*C[REPLSEQ]5R-"

.TABLE	"guppy:cnode ::= [ 0 +@seq 1 ] [ 1 -Newline 2 ] [ 2 {<gup:seqreduce>} -* ]"
	"[ 1 guppy:name 3 ] [ 3 @@= 4 ] [ 4 guppy:expr 5 ] [ 5 @for 6 ] [ 6 guppy:expr 7 ] [ 7 {<gup:replseqreduce>} -* ]"
	"[ 1 @for 8 ] [ 8 {<gup:null2push>} -* 6 ]"
	"[ 0 +@par 9 ] [ 9 -Newline 10 ] [ 10 {<gup:parreduce>} -* ]"

# }}}
.SECTION "guppy-cflow" # {{{: control-flow processes

.GRULE	"gup:ifreduce" "T+St0@tN+0C[IF]2R-"

.TABLE	"guppy:cflow ::= [ 0 +@if 1 ] [ 1 guppy:expr 2 ] [ 2 -Newline 3 ] [ 3 {<gup:ifreduce>} -* ]"

# }}}
.SECTION "guppy-assign" # {{{: assignment

.GRULE	"gup:assignreduce" "SN0N+N+V0C[ASSIGN]3R-"
.GRULE	"gup:isreduce" "SN0N+N+V0C[IS]3R-"

.TABLE	"guppy:oneassign ::= [ 0 guppy:name 1 ] [ 1 @@= 2 ] [ 2 guppy:expr 3 ] [ 3 {<gup:assignreduce>} -* ]"

# }}}
.SECTION "guppy-io" # {{{: input/output

.GRULE "gup:inputreduce" "SN0N+N+V0C[INPUT]3R-"
.GRULE "gup:outputreduce" "SN0N+N+V0C[OUTPUT]3R-"

.TABLE "guppy:input ::= [ 0 guppy:name 1 ] [ 1 @@? 2 ] [ 2 guppy:expr 3 ] [ 3 {<gup:inputreduce>} -* ]"

.TABLE "guppy:output ::= [ 0 guppy:name 1 ] [ 1 @@! 2 ] [ 2 guppy:expr 3 ] [ 3 {<gup:outputreduce>} -* ]"


# }}}
.SECTION "guppy-oper" # {{{: operators

.GRULE	"gup:foldaddreduce" "R+N+Sn00C[ADD]3R-"
.GRULE	"gup:foldsubreduce" "R+N+Sn00C[SUB]3R-"
.GRULE	"gup:sizereduce" "SN0N+0C[SIZE]2R-"
.GRULE	"gup:bytesinreduce" "SN0N+0C[BYTESIN]2R-"
.GRULE	"gup:foldarraysub" "R+N+Sn00C[ARRAYSUB]3R-"

# array/record things are fundamentally types, so..

.TABLE	"guppy:expr +:= [ 0 @size 1 ] [ 1 guppy:expr 2 ] [ 2 {<gup:sizereduce>} -* ]"
.TABLE	"guppy:expr +:= [ 0 @bytesin 1 ] [ 1 guppy:expr 2 ] [ 2 {<gup:bytesinreduce>} -* ]"


# for "guppy:restofexpr" existing expression is result already
.TABLE	"guppy:restofexpr +:= [ 0 @@+ 1 ] [ 1 guppy:expr 2 ] [ 2 {<gup:foldaddreduce>} -* ]"
	"[ 0 @@- 3 ] [ 3 guppy:expr 4 ] [ 4 {<gup:foldsubreduce>} -* ]"
	"[ 0 -* ]"

.TABLE	"guppy:restofexpr +:= [ 0 @@[ 1 ] [ 1 guppy:expr 2 ] [ 2 @@] 3 ] [ 3 {<gup:foldarraysub>} -* <guppy:restofexpr> ]"

# }}}
.SECTION "guppy-instance" # {{{

.GRULE	"gup:instancereduce" "SN0N+N+C[INSTANCE]2R-"

.BNF	"guppy:exprlist ::= { guppy:expr @@, 1 }"

.TABLE	"guppy:instance ::= [ 0 guppy:name 1 ] [ 1 @@( 2 ] [ 2 @@) 3 ] [ 3 {<gup:nullpush>} -* 6 ]"
	"[ 2 -* 4 ] [ 4 guppy:exprlist 5 ] [ 5 @@) 6 ] [ 6 {<gup:instancereduce>} -* ]"


# }}}


